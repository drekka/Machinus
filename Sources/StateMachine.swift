//
//  File.swift
//
//
//  Created by Derek Clarkson on 23/11/2022.
//

import Combine
import Foundation
import os

/// Defines the closures called after a state change finishes.
/// - parameter result: A result that either contains the previous state, or an error if the transition failed.
/// - parameter error: Any error generated by the transition.
public typealias TransitionCompletion<T> = (_ result: Result<T, Error>) -> Void where T: StateIdentifier

/// Defines closures called before and after a transition.
/// - parameter fromState: The previous state of the machine.
/// - parameter toState: The next state of the machine.
public typealias DidTransitionAction<T> = (_ fromState: T, _ toState: T) -> Void where T: StateIdentifier

/// Defines a result builder that can be used on the state machines init.
@resultBuilder
struct StateConfigBuilder<T> where T: StateIdentifier {
    static func buildBlock(_ configs: StateConfig<T>...) -> [StateConfig<T>] { configs }
}

/// Possible results of the transition pre-flight.
private enum PreflightResponse<T> where T: StateIdentifier {
    case allow
    case fail(error: StateMachineError)
    case redirect(to: T)
}

private extension BarrierResponse {

    /// Converts a transition barrier response into a pre-flight response.
    var asPreflightResponse: PreflightResponse<T> {
        switch self {
        case .allow: return .allow
        case .fail: return .fail(error: .transitionDenied)
        case .redirect(to: let redirectState): return .redirect(to: redirectState)
        }
    }
}

#if os(iOS) || os(tvOS)
    extension StateMachine: Machine {}
#endif

/// The implementation of a state machine.
public class StateMachine<T> where T: StateIdentifier {

    public static func generateName() -> String {
        UUID().uuidString + "<" + String(describing: T.self) + ">"
    }

    public typealias Output = T
    public typealias Failure = Never

    private var stateConfigs: [T: StateConfig<T>] = [:]
    private let transitionLock = NSLock()
    private let resetState: T
    private var didTransition: DidTransitionAction<T>?

    let currentState: CurrentValueSubject<T, Never>

    #if os(iOS) || os(tvOS)
        var iosStateObserver: IOSStateObserver<T>?
    #endif

    /// Readonly access to the machine's current state.
    public var state: T {
        currentState.value
    }

    // MARK: - Public interface

    /// The name of the machine. By default this is a randon UUID combined witt the type of the state identifiers.
    public let name: String

    /// If set to true, causes the machine to issue state change notifications through the default notification center.
    public var postNotifications = false

    /// Set to `DispatchQueue.main` by default, this is the queue used for executing transitions. Note that if running in synchronouse mode then this is disabled.
    public var transitionQ = DispatchQueue.main

    // MARK: - Lifecycle

    /// Convenience initializer which uses a result builder.
    ///
    /// - parameter name: The unqiue name of this state machine. If not passed then a unique UUID is used. Mostly used in logging.
    /// - parameter didTransition: A closure that is called after every a transition, Takes both the old and new states as arguments.
    /// - parameter state: A builder that defines a list of states.
    public convenience init(name: String = StateMachine.generateName(),
                            didTransition: DidTransitionAction<T>? = nil,
                            @StateConfigBuilder<T> withStates states: () -> [StateConfig<T>]) {
        self.init(name: name, didTransition: didTransition, withStates: states())
    }

    /// Convenience initializer which takes 3 or more state configs..
    ///
    /// - parameter name: The unqiue name of this state machine. If not passed then a unique UUID is used. Mostly used in logging.
    /// - parameter didTransition: A closure that is called after every a transition, Takes both the old and new states as arguments.
    /// - parameters states: At least 3 states that the engine will manage..
    public convenience init(name: String = StateMachine.generateName(),
                            didTransition: DidTransitionAction<T>? = nil,
                            withStates states: StateConfig<T>...) {
        self.init(name: name, didTransition: didTransition, withStates: states)
    }

    init(name: String = StateMachine.generateName(),
         didTransition: DidTransitionAction<T>?,
         withStates states: [StateConfig<T>]) {

        if states.count < 3 {
            fatalError("🤖 [\(name)] Must have at least 3 state configs")
        }

        self.name = name
        self.didTransition = didTransition
        resetState = states[0].identifier
        currentState = CurrentValueSubject(resetState)
        #if os(iOS) || os(tvOS)
            iosStateObserver = IOSStateObserver(machine: self, states: states)
        #endif

        states.forEach { state in
            if stateConfigs.keys.contains(state.identifier) {
                fatalError("🤖 [\(name)] Duplicate states detected with key \(state.identifier)")
            }
            stateConfigs[state.identifier] = state
        }
    }

    /// Resets the state machine to it's initial state which will be the first state the machine was initialised with.
    ///
    /// This also calls the initial state's `didEnter` closure.
    public func reset() {
        queueTransition { [weak self] in

            guard let self else { return }

            systemLog.trace("🤖 [\(self.name)] Resetting to initial state")
            let resetStateConfig = self.stateConfig(for: self.resetState)
            self.transition(toState: self.resetState, didExit: nil, didEnter: resetStateConfig.didEnter)
        }
    }

    // MARK: - Public transitions requests

    /// Requests a dynamic transition where the dynamic transition closure of the current state is executed to obtain the next state of the machine.
    ///
    /// - parameter completion: A closure that will be executed when the transition is completed.
    public func transition(completion: TransitionCompletion<T>? = nil) {
        queueTransition { [weak self] in

            guard let self else { return }

            guard let dynamicClosure = self.stateConfigs[self.state]?.dynamicTransition else {
                fatalError("🤖 [\(self.name)] No dynamic transition defined for \(self.state)")
            }
            systemLog.trace("🤖 [\(self.name)] Running dynamic transition")
            self.transitionToState(dynamicClosure(), completion: completion)
        }
    }

    /// Requests a transition to a specific state.
    ///
    /// - parameter state: The state to transition to.
    /// - parameter completion: A closure that will be executed when the transition is completed.
    public func transition(to state: T, completion: TransitionCompletion<T>? = nil) {
        queueTransition { [weak self] in
            guard let self else { return }
            self.transitionToState(state, completion: completion)
        }
    }

    // MARK: - Internal

    func stateConfig(for state: T) -> StateConfig<T> {
        guard let stateConfig = stateConfigs[state] else {
            fatalError("🤖 [\(name)] State \(state) not registered with this machine.")
        }
        return stateConfig
    }

    // Queues a transition that locks access then transitions.
    func queueTransition(_ block: @escaping () -> Void) {

        let execute: () -> Void = { [weak self] in
            guard let self else { return }
            systemLog.trace("🤖 [\(self.name)] Initiating transition")
            self.transitionLock.lock()
            block()
            self.transitionLock.unlock()
        }

        systemLog.trace("🤖 [\(self.name)] Adding locked transition block to queue")
        transitionQ.async(execute: execute)
    }

    // MARK: - Transition logic

    private func transitionToState(_ stateConfigGenerator: @autoclosure () -> T, completion: TransitionCompletion<T>?) {

        let currentState = stateConfig(for: state)
        let newState = stateConfig(for: stateConfigGenerator())
        switch preflightTransition(fromState: currentState, toState: newState) {

        case .fail(error: let error):
            systemLog.trace("🤖 [\(self.name)] Preflight failed: \(error.localizedDescription)")
            completion?(.failure(error))
            return

        case .redirect(to: let redirectState):
            systemLog.trace("🤖 [\(self.name)] Preflight redirecting to: \(String(describing: redirectState))")
            transitionToState(redirectState, completion: completion)

        case .allow:
            systemLog.trace("🤖 [\(self.name)] Preflight passed, transitioning ...")

            transition(toState: newState.identifier, didExit: currentState.didExit, didEnter: newState.didEnter)

            if postNotifications {
                NotificationCenter.default.postStateChange(machine: self, oldState: currentState.identifier)
            }

            // Complete with the old state.
            completion?(.success(currentState.identifier))
        }
    }

    private func preflightTransition(fromState: StateConfig<T>, toState: StateConfig<T>) -> PreflightResponse<T> {

        systemLog.trace("🤖 [\(self.name)] Preflighting transition to .\(String(describing: self.state))")

        // If the state is the same state then do nothing.
        if fromState == toState {
            systemLog.trace("🤖 [\(self.name)] Already in state .\(String(describing: fromState))")
            return .fail(error: .alreadyInState)
        }

        // Check for a final state transition
        if fromState.features.contains(.final) {
            systemLog.error("🤖 [\(self.name)] Final state, cannot transition")
            return .fail(error: .finalState)
        }

        /// Process the registered transition barrier.
        if let barrier = toState.transitionBarrier {
            systemLog.trace("🤖 [\(self.name)] Executing transition barrier")
            return barrier().asPreflightResponse
        }

        guard toState.features.contains(.global) || fromState.canTransition(toState: toState) else {
            systemLog.trace("🤖 [\(self.name)] Illegal transition")
            return .fail(error: .illegalTransition)
        }

        return .allow
    }

    func transition(toState: T, didExit: DidExitAction<T>?, didEnter: DidEnterAction<T>?) {
        let fromState = state
        currentState.value = toState
        didExit?(toState)
        didEnter?(fromState)
        didTransition?(fromState, toState)
    }
}

// MARK: - Combine

/// Extension that provides combine support to the machine.
extension StateMachine: Publisher {
    public func receive<S>(subscriber: S) where S: Subscriber, S.Input == Output, S.Failure == Failure {
        currentState.receive(subscriber: subscriber)
    }
}
