//
//  Machinus.swift
//  Machinus
//
//  Created by Derek Clarkson on 11/2/19.
//  Copyright © 2019 Derek Clarkson. All rights reserved.
//

import Combine
import os

/// Defines the closures called after a state change finishes.
/// - parameter result: A result that either contains the previous state, or an error if the transition failed.
/// - parameter error: Any error generated by the transition.
public typealias TransitionCompletion<T> = (_ result: Result<T, Error>) -> Void where T: StateIdentifier

/// Defines closures called before and after a transition.
/// - parameter fromState: The previous state of the machine.
/// - parameter toState: The next state of the machine.
public typealias TransitionAction<T> = (_ fromState: T, _ toState: T) -> Void where T: StateIdentifier

/// A implementation of a state machine.
public class StateMachine<T> where T: StateIdentifier {

    public typealias Output = T
    public typealias Failure = Never

    private var stateConfigs: [StateConfig<T>]

    private var currentState: StateConfig<T> {
        didSet {
            currentStateSubject.value = currentState.identifier
        }
    }

    private let currentStateSubject: CurrentValueSubject<T, Never>

    private var restoreState: StateConfig<T>!

    private var didTransition: TransitionAction<T>?

    private let transitionLock = NSLock()

    private var backgroundObserver: Any?
    private var foregroundObserver: Any?

    // MARK: - Public interface

    public let name: String

    public var state: T {
        return currentState.identifier
    }

    public var postNotifications = false

    public var transitionQ = DispatchQueue.main

    private var backgroundState: BackgroundStateConfig<T>! {
        didSet {
            startWatchingNotifications()
        }
    }

    // MARK: - Lifecycle

    deinit {
        stopWatchingNotifications()
    }

    /// Default initializer.
    ///
    /// - parameter name: The unqiue name of this state machine. Defaults to a unique UUID but can be set to something more readable. Mostly used in logging.
    /// - parameter didTransition: A closure that is called after every a transition, Takes both the old and new states as arguments.
    /// - parameter firstState: The first state's configuration which is also the initial state and the state that a `reset()` reverts to.
    /// - parameter secondState: The second state's configuration.
    /// - parameter thirdState: The third state's configuration.
    /// - parameter otherStates: Other state configurations if needed.
    public init(name: String = UUID().uuidString + "<" + String(describing: T.self) + ">",
                didTransition: TransitionAction<T>? = nil,
                withStates firstState: StateConfig<T>,
                _ secondState: StateConfig<T>,
                _ thirdState: StateConfig<T>,
                _ otherStates: StateConfig<T>...) {

        self.name = name
        self.didTransition = didTransition
        let states: [StateConfig<T>] = [firstState, secondState, thirdState] + otherStates

        stateConfigs = states
        currentState = firstState
        currentStateSubject = CurrentValueSubject(firstState.identifier)

        // Each state should be listed only once. Using a Set checks based on the hashable identifier.
        if Set(stateConfigs.map { $0.identifier }).count != stateConfigs.count {
            fatalError("🤖 Duplicate identifiers detected")
        }

        // Set the background state
        states.forEach { state in
            guard let state = state as? BackgroundStateConfig else { return }
            if backgroundState != nil {
                fatalError("🤖 Only one background is allowed per state machine. Both \(String(describing: backgroundState)) and \(String(describing: state)) are defined as background states.")
            }
            backgroundState = state
        }
    }

    public func reset() {
        currentState = stateConfigs[0]
    }

    // MARK: - Public transitions

    public func transition(completion: TransitionCompletion<T>? = nil) {
        guard let dynamicClosure = currentState.dynamicTransition else {
            fatalError("🤖 No dynamic transition defined for \(currentState)")
        }
        runTransitionProcess(nextState: {
            os_log(.debug, "🤖 %@: Running dynamic transition closure", self.name)
            return dynamicClosure()
        }, completion: completion)
    }

    public func transition(to state: T, completion: TransitionCompletion<T>? = nil) {
        runTransitionProcess(nextState: { state }, completion: completion)
    }

    // MARK: - Internal

    private func stopWatchingNotifications() {
        if let obs = backgroundObserver {
            NotificationCenter.default.removeObserver(obs)
        }
        if let obs = foregroundObserver {
            NotificationCenter.default.removeObserver(obs)
        }
    }

    private func startWatchingNotifications() {

        os_log(.debug, "🤖 %@: Watching application background notification", name)
        backgroundObserver = NotificationCenter.default.addObserver(forName: UIApplication.didEnterBackgroundNotification, object: nil, queue: nil) { [weak self] _ in
            guard let self = self else { return }
            os_log(.debug, "🤖 %@: Background notification received", self.name)
            self.transitionToBackground()
        }

        foregroundObserver = NotificationCenter.default.addObserver(forName: UIApplication.willEnterForegroundNotification, object: nil, queue: nil) { [weak self] _ in
            guard let self = self else { return }
            os_log(.debug, "🤖 %@: Foreground notification received", self.name)
            self.transitionToForeground()
        }
    }

    private func runSynchronised(block: @escaping () -> Void) {
        transitionQ.async {
            // Use a lock to defend against concurrent dispatch queue execution.
            self.transitionLock.lock()
            block()
            self.transitionLock.unlock()
        }
    }

    private func state(forIdentifier identifier: T) -> StateConfig<T> {
        guard let state = stateConfigs.first(where: { $0.identifier == identifier }) else {
            fatalError("🤖 State \(identifier) not registered with this machine.")
        }
        return state
    }

    // MARK: - Transition logic

    private func runTransitionProcess(nextState: @escaping () -> T, completion: TransitionCompletion<T>?) {
        runSynchronised { [weak self] in

            guard let self = self else { return }

            let toStateIdentifier = nextState()
            let toState = self.state(forIdentifier: toStateIdentifier)

            os_log(.debug, "🤖 %@: Transitioning to .%@", self.name, String(describing: toStateIdentifier))
            if let error = self.preflightTransition(toState: toState) {
                os_log(.debug, "🤖 %@: Preflight failed: %@", self.name, error.localizedDescription)
                completion?(.failure(error))
                return
            }

            self.executeTransition(toState: toState, completion: completion)
        }
    }

    private func preflightTransition(toState: StateConfig<T>) -> StateMachineError? {

        os_log(.debug, "🤖 %@: Pre-flighting transition ...", name)

        // If the state is the same state then do nothing.
        guard currentState != toState else {
            os_log(.debug, "🤖 %@: Already in state %@", name, String(describing: currentState))
            return .alreadyInState
        }

        // Check for a final state transition
        if currentState is FinalStateConfig {
            os_log(.error, "🤖 %@: Final state, cannot transition", name)
            return .finalState
        }

        if let barrier = toState.transitionBarrier, !barrier() {
            os_log(.debug, "🤖 %@: Transition barrier blocked transition", name)
            return .transitionDenied
        }

        guard currentState.canTransition(toState: toState) else {
            os_log(.debug, "🤖 %@: Illegal transition", name)
            return .illegalTransition
        }

        return nil
    }

    private func executeTransition(toState: StateConfig<T>, completion: TransitionCompletion<T>?) {

        os_log(.debug, "🤖 %@: Executing transition ...", name)
        let fromState = currentState
        currentState = toState

        fromState.didExit?(toState.identifier)
        toState.didEnter?(fromState.identifier)
        didTransition?(fromState.identifier, toState.identifier)

        if postNotifications {
            NotificationCenter.default.postStateChange(machine: self, oldState: fromState.identifier)
        }

        // Complete with the old state.
        completion?(.success(fromState.identifier))
    }

    private func transitionToBackground() {
        runSynchronised {
            guard let backgroundState = self.backgroundState else {
                fatalError("🤖 Transition to background state called when no background state set")
            }

            os_log(.debug, "🤖 %@: Transitioning to background state .%@", self.name, String(describing: backgroundState))
            self.restoreState = self.currentState
            self.currentState = backgroundState
            backgroundState.didEnter?(self.restoreState.identifier)
        }
    }

    private func transitionToForeground() {
        runSynchronised {
            guard let restoreState = self.restoreState else {
                fatalError("🤖 Transitioning to foreground called when machine has not transitioned to background")
            }

            os_log(.debug, "🤖 %@: Transitioning to foreground, restoring state .%@", self.name, String(describing: restoreState))
            self.currentState = restoreState
            self.restoreState = nil
            self.backgroundState?.didExit?(self.currentState.identifier)
        }
    }
}

// MARK: - Combine

extension StateMachine: Publisher {
    public func receive<S>(subscriber: S) where S: Subscriber, S.Input == Output, S.Failure == Failure {
        return currentStateSubject.receive(subscriber: subscriber)
    }
}
